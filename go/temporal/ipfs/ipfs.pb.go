// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/ipfs.proto

package ipfs // import "github.com/RTradeLtd/sdk/go/temporal/ipfs"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Key_RSA_Size int32

const (
	Key_RSA_S_2048 Key_RSA_Size = 0
	Key_RSA_S_3072 Key_RSA_Size = 1
	Key_RSA_S_4096 Key_RSA_Size = 2
)

var Key_RSA_Size_name = map[int32]string{
	0: "S_2048",
	1: "S_3072",
	2: "S_4096",
}
var Key_RSA_Size_value = map[string]int32{
	"S_2048": 0,
	"S_3072": 1,
	"S_4096": 2,
}

func (x Key_RSA_Size) String() string {
	return proto.EnumName(Key_RSA_Size_name, int32(x))
}
func (Key_RSA_Size) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ipfs_c7687f9f28c17af7, []int{2, 0, 0}
}

type Key_ED25519_Size int32

const (
	Key_ED25519_S_256 Key_ED25519_Size = 0
)

var Key_ED25519_Size_name = map[int32]string{
	0: "S_256",
}
var Key_ED25519_Size_value = map[string]int32{
	"S_256": 0,
}

func (x Key_ED25519_Size) String() string {
	return proto.EnumName(Key_ED25519_Size_name, int32(x))
}
func (Key_ED25519_Size) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ipfs_c7687f9f28c17af7, []int{2, 1, 0}
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_ipfs_c7687f9f28c17af7, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (dst *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(dst, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type KeysResp struct {
	Keys                 []*Key   `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeysResp) Reset()         { *m = KeysResp{} }
func (m *KeysResp) String() string { return proto.CompactTextString(m) }
func (*KeysResp) ProtoMessage()    {}
func (*KeysResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ipfs_c7687f9f28c17af7, []int{1}
}
func (m *KeysResp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeysResp.Unmarshal(m, b)
}
func (m *KeysResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeysResp.Marshal(b, m, deterministic)
}
func (dst *KeysResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeysResp.Merge(dst, src)
}
func (m *KeysResp) XXX_Size() int {
	return xxx_messageInfo_KeysResp.Size(m)
}
func (m *KeysResp) XXX_DiscardUnknown() {
	xxx_messageInfo_KeysResp.DiscardUnknown(m)
}

var xxx_messageInfo_KeysResp proto.InternalMessageInfo

func (m *KeysResp) GetKeys() []*Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

type Key struct {
	// Types that are valid to be assigned to Type:
	//	*Key_Rsa
	//	*Key_Ed25519
	Type                 isKey_Type `protobuf_oneof:"type"`
	Name                 string     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Id                   string     `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Key) Reset()         { *m = Key{} }
func (m *Key) String() string { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()    {}
func (*Key) Descriptor() ([]byte, []int) {
	return fileDescriptor_ipfs_c7687f9f28c17af7, []int{2}
}
func (m *Key) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Key.Unmarshal(m, b)
}
func (m *Key) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Key.Marshal(b, m, deterministic)
}
func (dst *Key) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key.Merge(dst, src)
}
func (m *Key) XXX_Size() int {
	return xxx_messageInfo_Key.Size(m)
}
func (m *Key) XXX_DiscardUnknown() {
	xxx_messageInfo_Key.DiscardUnknown(m)
}

var xxx_messageInfo_Key proto.InternalMessageInfo

type isKey_Type interface {
	isKey_Type()
}

type Key_Rsa struct {
	Rsa *Key_RSA `protobuf:"bytes,1,opt,name=rsa,proto3,oneof"`
}

type Key_Ed25519 struct {
	Ed25519 *Key_ED25519 `protobuf:"bytes,2,opt,name=ed25519,proto3,oneof"`
}

func (*Key_Rsa) isKey_Type() {}

func (*Key_Ed25519) isKey_Type() {}

func (m *Key) GetType() isKey_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Key) GetRsa() *Key_RSA {
	if x, ok := m.GetType().(*Key_Rsa); ok {
		return x.Rsa
	}
	return nil
}

func (m *Key) GetEd25519() *Key_ED25519 {
	if x, ok := m.GetType().(*Key_Ed25519); ok {
		return x.Ed25519
	}
	return nil
}

func (m *Key) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Key) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Key) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Key_OneofMarshaler, _Key_OneofUnmarshaler, _Key_OneofSizer, []interface{}{
		(*Key_Rsa)(nil),
		(*Key_Ed25519)(nil),
	}
}

func _Key_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Key)
	// type
	switch x := m.Type.(type) {
	case *Key_Rsa:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rsa); err != nil {
			return err
		}
	case *Key_Ed25519:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ed25519); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Key.Type has unexpected type %T", x)
	}
	return nil
}

func _Key_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Key)
	switch tag {
	case 1: // type.rsa
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Key_RSA)
		err := b.DecodeMessage(msg)
		m.Type = &Key_Rsa{msg}
		return true, err
	case 2: // type.ed25519
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Key_ED25519)
		err := b.DecodeMessage(msg)
		m.Type = &Key_Ed25519{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Key_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Key)
	// type
	switch x := m.Type.(type) {
	case *Key_Rsa:
		s := proto.Size(x.Rsa)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Key_Ed25519:
		s := proto.Size(x.Ed25519)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Key_RSA struct {
	Size                 Key_RSA_Size `protobuf:"varint,1,opt,name=size,proto3,enum=ipfs.Key_RSA_Size" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Key_RSA) Reset()         { *m = Key_RSA{} }
func (m *Key_RSA) String() string { return proto.CompactTextString(m) }
func (*Key_RSA) ProtoMessage()    {}
func (*Key_RSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_ipfs_c7687f9f28c17af7, []int{2, 0}
}
func (m *Key_RSA) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Key_RSA.Unmarshal(m, b)
}
func (m *Key_RSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Key_RSA.Marshal(b, m, deterministic)
}
func (dst *Key_RSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key_RSA.Merge(dst, src)
}
func (m *Key_RSA) XXX_Size() int {
	return xxx_messageInfo_Key_RSA.Size(m)
}
func (m *Key_RSA) XXX_DiscardUnknown() {
	xxx_messageInfo_Key_RSA.DiscardUnknown(m)
}

var xxx_messageInfo_Key_RSA proto.InternalMessageInfo

func (m *Key_RSA) GetSize() Key_RSA_Size {
	if m != nil {
		return m.Size
	}
	return Key_RSA_S_2048
}

type Key_ED25519 struct {
	Size                 Key_ED25519_Size `protobuf:"varint,1,opt,name=size,proto3,enum=ipfs.Key_ED25519_Size" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Key_ED25519) Reset()         { *m = Key_ED25519{} }
func (m *Key_ED25519) String() string { return proto.CompactTextString(m) }
func (*Key_ED25519) ProtoMessage()    {}
func (*Key_ED25519) Descriptor() ([]byte, []int) {
	return fileDescriptor_ipfs_c7687f9f28c17af7, []int{2, 1}
}
func (m *Key_ED25519) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Key_ED25519.Unmarshal(m, b)
}
func (m *Key_ED25519) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Key_ED25519.Marshal(b, m, deterministic)
}
func (dst *Key_ED25519) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key_ED25519.Merge(dst, src)
}
func (m *Key_ED25519) XXX_Size() int {
	return xxx_messageInfo_Key_ED25519.Size(m)
}
func (m *Key_ED25519) XXX_DiscardUnknown() {
	xxx_messageInfo_Key_ED25519.DiscardUnknown(m)
}

var xxx_messageInfo_Key_ED25519 proto.InternalMessageInfo

func (m *Key_ED25519) GetSize() Key_ED25519_Size {
	if m != nil {
		return m.Size
	}
	return Key_ED25519_S_256
}

func init() {
	proto.RegisterType((*Empty)(nil), "ipfs.Empty")
	proto.RegisterType((*KeysResp)(nil), "ipfs.KeysResp")
	proto.RegisterType((*Key)(nil), "ipfs.Key")
	proto.RegisterType((*Key_RSA)(nil), "ipfs.Key.RSA")
	proto.RegisterType((*Key_ED25519)(nil), "ipfs.Key.ED25519")
	proto.RegisterEnum("ipfs.Key_RSA_Size", Key_RSA_Size_name, Key_RSA_Size_value)
	proto.RegisterEnum("ipfs.Key_ED25519_Size", Key_ED25519_Size_name, Key_ED25519_Size_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TemporalIPFSClient is the client API for TemporalIPFS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TemporalIPFSClient interface {
	// Keys returns the IPFS keys associated with an authenticated request.
	Keys(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*KeysResp, error)
	// NewKey generates a new IPFS key associated with an authenticated request.
	NewKey(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Empty, error)
}

type temporalIPFSClient struct {
	cc *grpc.ClientConn
}

func NewTemporalIPFSClient(cc *grpc.ClientConn) TemporalIPFSClient {
	return &temporalIPFSClient{cc}
}

func (c *temporalIPFSClient) Keys(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*KeysResp, error) {
	out := new(KeysResp)
	err := c.cc.Invoke(ctx, "/ipfs.TemporalIPFS/Keys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *temporalIPFSClient) NewKey(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ipfs.TemporalIPFS/NewKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

